https://blog.csdn.net/blueling51/article/details/6928900
StringBuilder 没有提供clear或empty方法。
清空有3种方法：
1）新生成一个，旧的由系统自动回收
2）使用delete *** 推荐
3）使用setLength
将三种方法循环1000万次，代码：

注意append的字符串要都不相同，否则会因为java 的String  pool对结果造成影响（即3好于2），结果：
1.Way1=9438
2.Way2=6281
3.Way3=6469

可以将各方法多重复几次，点到顺序，等
总体来看：方法2好于方法3好于方法1


=========================================================================================================================================================================================
=======================================写的非常好，必须仔细阅读5遍以上=======================================================================================================================
=========================================================================================================================================================================================
GC:
https://blog.csdn.net/weixin_34109408/article/details/85748049   
GC：Garbage Collection 垃圾收集
1960年 Lisp使用了GC
Java中，GC的对象是Java堆和方法区（即永久区）

五、复制算法：（新生代的GC）
现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。
当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。
=========================================================================================================================================================================================
=========================================================================================================================================================================================
=========================================================================================================================================================================================





